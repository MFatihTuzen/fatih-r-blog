{
  "hash": "969d69352a3e803d0536c365d14a0aed",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exploring apply, sapply, lapply, and map Functions in R\"\nauthor: \"M. Fatih TÃ¼zen\"\ndate: \"2024-04-15\"\ndate-modified: \"2024-04-15\"\ncategories: [R Programming, apply, sapply, lapply, map]\n---\n\n\n## **Introduction**\n\n![https://www.tumblr.com/jake-clark/100946716432?source=share](/posts/2021-04-15_apply_map/apply_map.png){fig-align=\"center\"}\n\nIn R programming, Apply functions (**`apply()`**, **`sapply()`**, **`lapply()`**) and the **`map()`** function from the purrr package are powerful tools for data manipulation and analysis. In this comprehensive guide, we will delve into the syntax, usage, and examples of each function, including the usage of built-in functions and additional arguments, as well as performance benchmarking.\n\n## Understanding apply() Function\n\nThe `apply()` function in R is used to apply a specified function to the rows or columns of an array. Its syntax is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(X, MARGIN, FUN, ...)\n```\n:::\n\n\n-   **`X`**: The input data, typically an array or matrix.\n\n-   **`MARGIN`**: A numeric vector indicating which margins should be retained. Use **`1`** for rows, **`2`** for columns.\n\n-   **`FUN`**: The function to apply.\n\n-   **`...`**: Additional arguments to be passed to the function.\n\nLet's calculate the mean of each row in a matrix using **`apply()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_data <- matrix(1:9, nrow = 3)\nrow_means <- apply(matrix_data, 1, mean)\nprint(row_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6\n```\n\n\n:::\n:::\n\n\nThis example computes the mean of each row in the matrix.\n\nLet's calculate the standard deviation of each column in a matrix and specify additional arguments (**`na.rm = TRUE`**) using **`apply()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumn_stdev <- apply(matrix_data, 2, sd, na.rm = TRUE)\nprint(column_stdev)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1\n```\n\n\n:::\n:::\n\n\n## Understanding sapply() Function\n\nThe **`sapply()`** function is a simplified version of **`lapply()`** that returns a vector or matrix. Its syntax is similar to **`lapply()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(X, FUN, ...)\n```\n:::\n\n\n-   **`X`**: The input data, typically a list.\n\n-   **`FUN`**: The function to apply.\n\n-   **`...`**: Additional arguments to be passed to the function.\n\nLet's calculate the sum of each element in a list using **`sapply()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_list <- list(a = 1:3, b = 4:6, c = 7:9)\nsum_results <- sapply(num_list, sum)\nprint(sum_results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 6 15 24 \n```\n\n\n:::\n:::\n\n\nThis example computes the sum of each element in the list.\n\nLet's convert each element in a list to uppercase using **`sapply()`** and the **`toupper()`** function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext_list <- list(\"hello\", \"world\", \"R\", \"programming\")\nuppercase_text <- sapply(text_list, toupper)\nprint(uppercase_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HELLO\"       \"WORLD\"       \"R\"           \"PROGRAMMING\"\n```\n\n\n:::\n:::\n\n\nHere, **`sapply()`** applies the **`toupper()`** function to each element in the list, converting them to uppercase.\n\n## Understanding lapply() Function\n\nThe **`lapply()`** function applies a function to each element of a list and returns a list. Its syntax is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X, FUN, ...)\n```\n:::\n\n\n-   **`X`**: The input data, typically a list.\n\n-   **`FUN`**: The function to apply.\n\n-   **`...`**: Additional arguments to be passed to the function.\n\nLet's apply a custom function to each element of a list using **`lapply()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_list <- list(a = 1:3, b = 4:6, c = 7:9)\ncustom_function <- function(x) sum(x) * 2\nresult_list <- lapply(num_list, custom_function)\nprint(result_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 12\n\n$b\n[1] 30\n\n$c\n[1] 48\n```\n\n\n:::\n:::\n\n\nIn this example, **`lapply()`** applies the custom function to each element in the list.\n\nLet's extract the vowels from each element in a list of words using **`lapply()`** and a custom function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_list <- list(\"apple\", \"banana\", \"orange\", \"grape\")\nvowel_list <- lapply(word_list, function(word) grep(\"[aeiou]\", strsplit(word, \"\")[[1]], value = TRUE))\nprint(vowel_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"a\" \"e\"\n\n[[2]]\n[1] \"a\" \"a\" \"a\"\n\n[[3]]\n[1] \"o\" \"a\" \"e\"\n\n[[4]]\n[1] \"a\" \"e\"\n```\n\n\n:::\n:::\n\n\nHere, **`lapply()`** applies the custom function to each element in the list, extracting vowels from words.\n\n## Understanding map() Function\n\nThe **`map()`** function from the purrr package is similar to **`lapply()`** but offers a more consistent syntax and returns a list. Its syntax is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(.x, .f, ...)\n```\n:::\n\n\n-   **`.x`**: The input data, typically a list.\n\n-   **`.f`**: The function to apply.\n\n-   **`...`**: Additional arguments to be passed to the function.\n\nLet's apply a lambda function to each element of a list using **`map()`**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nnum_list <- list(a = 1:3, b = 4:6, c = 7:9)\nmapped_results <- map(num_list, ~ .x^2)\nprint(mapped_results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 4 9\n\n$b\n[1] 16 25 36\n\n$c\n[1] 49 64 81\n```\n\n\n:::\n:::\n\n\nIn this example, **`map()`** applies the lambda function (squared) to each element in the list.\n\nLet's calculate the lengths of strings in a list using **`map()`** and the **`nchar()`** function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext_list <- list(\"hello\", \"world\", \"R\", \"programming\")\nstring_lengths <- map(text_list, nchar)\nprint(string_lengths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 5\n\n[[2]]\n[1] 5\n\n[[3]]\n[1] 1\n\n[[4]]\n[1] 11\n```\n\n\n:::\n:::\n\n\nHere, **`map()`** applies the **`nchar()`** function to each element in the list, calculating the length of each string.\n\n## Understanding map() Function Variants\n\nIn addition to the **`map()`** function, the purrr package provides several variants that are specialized for different types of output: **`map_lgl()`**, **`map_int()`**, **`map_dbl()`**, and **`map_chr()`**. These variants are particularly useful when you expect the output to be of a specific data type, such as logical, integer, double, or character.\n\n-   **`map_lgl()`**: This variant is used when the output of the function is expected to be a logical vector.\n\n-   **`map_int()`**: Use this variant when the output of the function is expected to be an integer vector.\n\n-   **`map_dbl()`**: This variant is used when the output of the function is expected to be a double vector.\n\n-   **`map_chr()`**: Use this variant when the output of the function is expected to be a character vector.\n\nThese variants provide stricter type constraints compared to the generic **`map()`** function, which can be useful for ensuring the consistency of the output type across iterations. They are particularly handy when working with functions that have predictable output types.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\n# Define a list of vectors\nnum_list <- list(a = 1:3, b = 4:6, c = 7:9)\n\n# Use map_lgl() to check if all elements in each vector are even\neven_check <- map_lgl(num_list, function(x) all(x %% 2 == 0))\nprint(even_check)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a     b     c \nFALSE FALSE FALSE \n```\n\n\n:::\n\n```{.r .cell-code}\n# Use map_int() to compute the sum of each vector\nvector_sums <- map_int(num_list, sum)\nprint(vector_sums)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c \n 6 15 24 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Use map_dbl() to compute the mean of each vector\nvector_means <- map_dbl(num_list, mean)\nprint(vector_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n2 5 8 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Use map_chr() to convert each vector to a character vector\nvector_strings <- map_chr(num_list, toString)\nprint(vector_strings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        a         b         c \n\"1, 2, 3\" \"4, 5, 6\" \"7, 8, 9\" \n```\n\n\n:::\n:::\n\n\nBy using these specialized variants, you can ensure that the output of your mapping operation adheres to your specific data type requirements, leading to cleaner and more predictable code.\n\n## **Performance Comparison**\n\nTo compare the performance of these functions, it's important to note that the execution time may vary depending on the hardware specifications of your computer, the size of the dataset, and the complexity of the operations performed. While one function may perform better in one scenario, it may not be the case in another. Therefore, it's recommended to benchmark the functions in your specific use case.\n\nLet's benchmark the computation of the sum of a large list using different functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\n\n# Create a 100 x 100 matrix\nmatrix_data <- matrix(rnorm(10000), nrow = 100)\n\n# Use apply() function to compute the sum for each column\nbenchmark_results <- microbenchmark(\n  apply_sum = apply(matrix_data, 2, sum),\n  sapply_sum = sapply(matrix_data, sum),\n  lapply_sum = lapply(matrix_data, sum),\n  map_sum = map_dbl(as.list(matrix_data), sum),  # We need to convert the matrix to a list for the map function\n  times = 100\n)\n\nprint(benchmark_results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n       expr      min       lq     mean    median       uq       max neval\n  apply_sum   95.301  112.351  140.424  125.4015  140.252  1529.901   100\n sapply_sum 2309.901 2379.101 2707.471 2454.8015 2654.302  4276.501   100\n lapply_sum 2142.901 2191.051 2512.500 2269.2010 2418.151  4217.202   100\n    map_sum 5112.401 5231.951 5942.505 5413.8015 6564.451 12283.101   100\n```\n\n\n:::\n:::\n\n\n**`apply_sum`** demonstrates the fastest processing time among the alternatives,. These results suggest that while **`apply()`** function offers the fastest processing time, it's still relatively slow compared to other options. When evaluating these results, it's crucial to consider factors beyond processing time, such as usability and functionality, to select the most suitable function for your specific needs.\n\nOverall, the choice of function depends on factors such as speed, ease of use, and compatibility with the data structure. It's essential to benchmark different alternatives in your specific use case to determine the most suitable function for your needs.\n\n## **Conclusion**\n\nApply functions (**`apply()`**, **`sapply()`**, **`lapply()`**) and the **`map()`** function from the purrr package are powerful tools for data manipulation and analysis in R. Each function has its unique features and strengths, making them suitable for various tasks.\n\n-   **`apply()`** function is versatile and operates on matrices, allowing for row-wise or column-wise operations. However, its performance may vary depending on the size of the dataset and the nature of the computation.\n\n-   **`sapply()`** and **`lapply()`** functions are convenient for working with lists and provide more optimized implementations compared to **`apply()`**. They offer flexibility and ease of use, making them suitable for a wide range of tasks.\n\n-   **`map()`** function offers a more consistent syntax compared to **`lapply()`** and provides additional variants (**`map_lgl()`**, **`map_int()`**, **`map_dbl()`**, **`map_chr()`**) for handling specific data types. While it may exhibit slower performance in some cases, its functionality and ease of use make it a valuable tool for functional programming in R.\n\nWhen choosing the most suitable function for your task, it's essential to consider factors beyond just performance. Usability, compatibility with data structures, and the nature of the computation should also be taken into account. Additionally, the performance of these functions may vary depending on the hardware specifications of your computer, the size of the dataset, and the complexity of the operations performed. Therefore, it's recommended to benchmark the functions in your specific use case and evaluate them based on multiple criteria to make an informed decision.\n\nBy mastering these functions and understanding their nuances, you can streamline your data analysis workflows and tackle a wide range of analytical tasks with confidence in R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}